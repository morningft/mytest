一、列表的相加是怎样实现的？元组的相加又是怎样实现的？
  
  答：列表相加：①利用操作符+，如：a=[1,2,3],b=[4,5,6],c=a+b=[1,2,3,4,5,6]；
                ②利用extend，如：a=[1,2,3],b=[4,5,6],a.extend(b)，a的结果[1,2,3,4,5,6]。
                +生成了一个新对象，而extend是修改原对象。
      元组相加：采用操作符+

二、内嵌函数和闭包有什么区别？
  
  答：内嵌函数：又称内置函数，即在函数中定义函数，内嵌函数的作用域在外部函数之内；
      闭包：闭包是函数式编程的重要语法结构，提高了代码的可重复使用性。当一个内嵌函数引用其外部作用域的变量就会得到一个闭包。
      创建闭包必须满足一下几点：①必须有一个内嵌函数；②内嵌函数必须引用外部函数中的变量；③外部函数的返回值必须是内嵌函数。

三、python中常用的工具包有哪些？
  答：1.字符串处理：①re：正则表达式的标准库；
                    ②StringIO/cStringIO:以读写文件的方式操作字符串；
                    ③chardet:可以猜测任意一段文本的字符集编码，对于编码类型未知的文本，很有用。可以作为模块来使用，也可以作为命令行工具来使用。
      2.数学类：    ①math：数学标准库，封装了常用的数学函数；
                    ②random:用于生成随机数；
                    ③fractions:封装跟有理数（分数）相关的运算。
      3.安全类：    ①hashlib:计算各种散列值，支持的哈希算法有（MD5,SHA1,SHA224,SHA256,SHA384,SHA512）;
                    ②PyCrypto:包含常用的对称加密算法（DES,AES,IDEA)；
                    ③pyOpenSSL:这个库使用python对OpenSSL进行很薄的封装;
      4.数据结构类：collections模块中的namedtuple、defaultdict、deque、counter、ordereddict、ChainMap；
      5.web重要类：requests 中的urllib、urllib2、urllib3(基于HTTP的重要模块)。

四、__new__ 和 __init__ 的区别？

  答：①__new__是一个静态方法，而__init__是一个实例方法；
      ②__new__方法会返回一个创建的实例，__init__什么都不返回；
      ③只有在__new__返回一个cls的实例时后边的__init__才能被调用；
      ④当创建一个新实例时调用__new__,初始化一个实例时用__init__。

五、用python 怎样实现文件的读写功能（怎样实现python中的with功能）？

  答：文件读写的操作步骤如下：①打开文件，获取文件描述符；②操作文件描述符的读写；③关闭文件。

     with语句不仅仅用于文件操作，实际上是一个很通用的结构，允许使用上下文管理器。上下文管理器是一种支持
__enter__()和__exit__()这两个方法的对象，__enter__()方法不带任何参数，在进入with语句块的时候被调用，该方法的返回值会被
赋值给as关键字之后的变量。__exit__()方法带有3个参数：type(异常类型)、value(异常信息)、trace(异常栈)，当with语句的代码块
执行完毕或执行过程中因为异常而被终止都会调用__exit__()方法。正常退出时该方法的3个参数都为None，异常退出时该方法的3个参数
会被分别赋值。如果__exit__()方法返回值（真值测试结果）为True则表示异常已经被处理，命令执行结果中就不会抛出异常信息了；
反之，如果__exit__()方法返回值（真值测试结果）为False，则表示异常没有被处理并且会向外抛出该异常。
   
    with在操作文件时可以自动关闭文件，简化操作。其功能可用try...except...finally..异常处理机制来代替，无论有无异常，最终
都将文件关闭掉。


六、python中常用的数据结构有哪些？
  
   答：①列表[list]--deque
       ②元组(tuple)--namedtuple
       ③字典{dict}--counter、ordereddict、ChainMap
       ④集合({set})
       ⑤列表推导式

七、字典中哪些数据类型可以成为key值（或是满足了怎样的条件就可以成为字典的key值）？

   答：凡是可哈希的数据结构都可以作为字典的键值。可哈希：一个对象在自己的生命周期中是不可变的（不可变的数据结构），
则称该对象是可哈希的。字典的键值基本原则是唯一且不可变，其存储结构是一张哈希表，所以可哈希的对象都可以作为字典的键值。
数值、字符串、元组、frozenset等都可以作为字典的键值；列表、字典、集合等不可以作为字典的键值。

八、python生成器在实际程序中怎样展现出来的？
   
   答：生成器函数：一个函数中包含了yield关键字，那么这个函数就是生成器函数，调用生成器函数，不会立马执行该函数里边的代码，
而是回返回一个生成器。生成器可以将列表推导式的[]改成()，不会将所有的值一次性加载到内存当中，延迟计算，一次返回一个结果，
不会一次生成所有结果；省内存，提高代码的可读性，生成器只能遍历一次。

九、什么是列表推导式？具体有何优点？

   答：列表推导式是python中一种常用的数据结构。列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于
某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据判断条件创建子序列。每个列表推导式都在for之后跟一个表达式，
然后有0或多个for或if子句，返回结果是一个根据表达从其后的for和if上下文环境中生成出来的列表，如果希望表达式推导出一个元组，
就必须使用括号。

  例：list=[2,4,6]
      list1=[4,3,-9]
      freshfruit=['  banana',' loganberry ','passion fruit  ']
     >>>[3*x for x in list]--->[6,12,18]
     >>>[[x,x**2] for x in list]--->[[2,4],[4,16],[6,36]]
     >>>[2*x for x in list if x>4]--->[8,12]
     >>>[2*x for x in list if x<2]--->[]
     >>>[a.strip() for a in freshfruit]--->['banana','loganberry','passion fruit']
     >>>[x*y for x in list for y in list1]--->[8,6,-18,16,12,-36,24,18,-54]
     >>>[list[i]*list1[1] for in in range(len(list))]--->[8,12,-54]
     >>>[str(round(355/113,i)) for i in range(1,6)]--->['3.1','3.14','3.142','3,1416','3.14159']

列表推导式将所有的值一次性加载到内存中，可以遍历任意次；利用其它列表可以创建新列表；


十、列表的sort()排序方法和python内置sorted排序方法有什么区别？

   答：sort()函数是list列表中内置的函数，而sorted()可以对list或者iterator进行排序；用sort函数对列表排序会影响列表本身，
而sorted()不会，python内置的全局sorted()方法对可迭代的序列排序生成新的序列；sorted()对所有的可迭代序列都有效。


十一、列表、字典、元组如何实现比较大小的？

   答：列表比较：==、>、< 或者使用 is，返回布尔值true或False。列表比较是从第一个元素顺序开始比较，如果相等则继续，直到找到
第一个不相等的元素并返回比较结果，如果一个列表的所有元素与另一个列表对应位置的元素都相等，则长的列表大。
      字典的比较都是通过返回的整数值来比较大小的，字典的比较提供了一个cmp()方法：①比较字典的长度，如果字典的长度不同，
用cmp(dict1,dict2)比较大小时，若果dict1比dict2长，cmp()返回正值，反之返回负值，字典中键的个数越多，这个字典就越大；
②比较字典的键，如果两个字典的长度相等，就比较字典的键，键的比较顺序和keys()方法返回键的顺序相同（相同的键会映射到哈希表
的同一位置，保证字典键的检查的一致性），若果两个字典的键不匹配，对这两个键比较大小就可以了，如果dict1中的第一个不同的键
大于dict2中第一个不同的键，cmp()返回正值；③如果两个字典的长度相同并且他们的键也相同，则用 每个相同的键所对应的值进行比较，
一旦出现不匹配的值，就可以对字典进行比较了，如果dict1比dict2中相同的键的值大，cmp()返回正值，dict1>dict2;④如果两个字典
有相同的长度 ，相同的键，相同的值，则两个字典相同，cmp()返回0。






